name: Release

on:
  push:
    branches:
      - "main"
      - "develop"
    tags:
      - "v*"
    paths-ignore:
      - ".github/ISSUE_TEMPLATE/**"
      - ".github/images/**"
      - "**.md"
  pull_request:
    paths-ignore:
      - ".github/ISSUE_TEMPLATE/**"
      - ".github/images/**"
      - "**.md"

env:
  REGISTRY: ghcr.io
  REGISTRY_IMAGE: ghcr.io/${{ github.repository }}
  GO_VERSION: "1.23.4"

permissions:
  contents: write
  packages: write
  # id-token: write # Only needed for keyless signing, not used here yet

jobs:
  test:
    strategy:
      fail-fast: true
      matrix:
        os: [ ubuntu-latest ]
    name: Test ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run Tests with Race Detection
        run: make test-race

      - name: Generate Test Summary
        # Explicitly list non-GUI packages for test summary generation
        run: go run gotest.tools/gotestsum@latest --junitfile unit-tests.xml --format pkgname -- github.com/autobrr/mkbrr/cmd github.com/autobrr/mkbrr/internal/...

      - name: Test Summary
        uses: test-summary/action@v2
        with:
          paths: "unit-tests.xml"
        if: always()

  testother:
    strategy:
      fail-fast: true
      matrix:
        os: [ macos-latest, windows-latest ]
    name: Test ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    env:
      GOPATH: ${{ startsWith(matrix.os, 'windows') && 'D:\golang\go' || '' }}
      GOCACHE: ${{ startsWith(matrix.os, 'windows') && 'D:\golang\cache' || '' }}
      GOMODCACHE: ${{ startsWith(matrix.os, 'windows') && 'D:\golang\modcache' || '' }}
      USERPROFILE: ${{ startsWith(matrix.os, 'windows') && 'D:\homedir' || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run Tests (MacOS)
        if: matrix.os == 'macos-latest'
        env:
          CGO_ENABLED: 0
        run: go test github.com/autobrr/mkbrr/cmd github.com/autobrr/mkbrr/internal/... # Explicitly list non-GUI packages to test

      - name: Run Tests (Windows)
        if: matrix.os == 'windows-latest'
        env:
          CGO_ENABLED: 0
        run: go test -short github.com/autobrr/mkbrr/cmd github.com/autobrr/mkbrr/internal/...

      - name: Generate Test Summary
        if: matrix.os != 'windows-latest'
        run: go run gotest.tools/gotestsum@latest --junitfile unit-tests.xml --format pkgname

      - name: Test Summary
        uses: test-summary/action@v2
        with:
          paths: "unit-tests.xml"
        if: always() && matrix.os != 'windows-latest'

  pgo:
    name: Generate PGO Profile
    runs-on: ubuntu-latest
    needs: [ test, testother ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      # Create test data for profiling
      - name: Create test data
        shell: bash
        run: |
          mkdir -p test_data
          dd if=/dev/urandom of=test_data/test1.bin bs=1M count=100
          dd if=/dev/urandom of=test_data/test2.bin bs=1M count=100
          for i in {1..20000}; do dd if=/dev/urandom bs=1023 count=1 of=test_data/file$i.bin >/dev/null 2>&1; done

      - name: Generate Profile
        env:
          CGO_ENABLED: 0
        run: |
          # Build initial binary
          # Build from the correct main package path
          go build -o mkbrr ./cmd/mkbrr/

          # Run different workload scenarios
          ./mkbrr create test_data/test1.bin --cpuprofile=cpu1.pprof
          ./mkbrr create test_data/test2.bin --cpuprofile=cpu2.pprof
          ./mkbrr create test_data --cpuprofile=cpu3.pprof

          # Verify profiles exist
          if [ ! -f cpu1.pprof ] || [ ! -f cpu2.pprof ] || [ ! -f cpu3.pprof ]; then
            echo "Error: One or more profile files not generated"
            ls -la *.pprof
            exit 1
          fi

          # Merge profiles
          go tool pprof -proto cpu1.pprof cpu2.pprof cpu3.pprof > cpu.pprof

          # Verify final profile
          if [ ! -s cpu.pprof ]; then
            echo "Error: Final profile not generated or empty"
            exit 1
          fi

      - name: Upload pprof
        uses: actions/upload-artifact@v4
        with:
          name: pprof
          path: cpu.pprof

  prepare:
    name: Prepare release (${{ matrix.os }})
    needs: [ pgo ]
    strategy:
      fail-fast: false # Allow other jobs to finish even if one fails
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Ensure tags are fetched

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download pprof artifact
        uses: actions/download-artifact@v4
        with:
          name: pprof
          path: .

      - name: Get short SHA
        id: sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # Cache dist directory per OS based on commit SHA
      # Note: Caching might be less effective for PRs/branch builds if they don't reuse commits often
      - name: Cache GoReleaser dist directory (Linux)
        uses: actions/cache@v4
        if: matrix.os == 'ubuntu-latest'
        with:
          path: dist/linux* # Cache linux specific dist outputs
          key: goreleaser-dist-linux-${{ steps.sha.outputs.sha_short }}-${{ github.ref }}
          restore-keys: |
            goreleaser-dist-linux-${{ steps.sha.outputs.sha_short }}-

      - name: Cache GoReleaser dist directory (macOS)
        uses: actions/cache@v4
        if: matrix.os == 'macos-latest'
        with:
          path: dist/darwin* # Cache darwin specific dist outputs
          key: goreleaser-dist-darwin-${{ steps.sha.outputs.sha_short }}-${{ github.ref }}
          restore-keys: |
            goreleaser-dist-darwin-${{ steps.sha.outputs.sha_short }}-

      - name: Cache GoReleaser dist directory (Windows)
        uses: actions/cache@v4
        if: matrix.os == 'windows-latest'
        with:
          path: dist/windows* # Cache windows specific dist outputs
          key: goreleaser-dist-windows-${{ steps.sha.outputs.sha_short }}-${{ github.ref }}
          restore-keys: |
            goreleaser-dist-windows-${{ steps.sha.outputs.sha_short }}-
          # enableCrossOsArchive: true # Might not be needed if only caching native builds

      # Run GoReleaser build/split phase
      # Only use --split for actual tag releases
      - name: Run GoReleaser Prepare Phase
        id: goreleaser-prepare
        uses: goreleaser/goreleaser-action@v6
        # Check if cache was hit for the specific OS dist directory
        # If cache hit, skip running goreleaser build/split again
        if: steps.cache-${{ matrix.os }}.outputs.cache-hit != 'true'
        with:
          distribution: goreleaser-pro
          version: "~> v2"
          args: ${{ startsWith(github.ref, 'refs/tags/') && 'release --clean --split' || 'build --snapshot --clean' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
          BUILDER: ${{ github.actor }}@github-actions-${{ matrix.os }}

  release:
    name: Merge and Publish Release
    needs: [ prepare ]
    runs-on: ubuntu-latest # Merge step typically runs on a single runner
    # Only run the merge/publish job for tag pushes
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true # Cache Go modules

      - name: Get short SHA
        id: sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # Restore all cached dist directories from prepare jobs
      - name: Restore GoReleaser dist cache (Linux)
        uses: actions/cache@v4
        with:
          path: dist/linux*
          key: goreleaser-dist-linux-${{ steps.sha.outputs.sha_short }}-${{ github.ref }}
          # No restore-keys needed here, we need the exact cache from prepare

      - name: Restore GoReleaser dist cache (macOS)
        uses: actions/cache@v4
        with:
          path: dist/darwin*
          key: goreleaser-dist-darwin-${{ steps.sha.outputs.sha_short }}-${{ github.ref }}

      - name: Restore GoReleaser dist cache (Windows)
        uses: actions/cache@v4
        with:
          path: dist/windows*
          key: goreleaser-dist-windows-${{ steps.sha.outputs.sha_short }}-${{ github.ref }}

      # Run GoReleaser merge/publish phase
      - name: Run GoReleaser Merge Phase
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: "~> v2"
          args: release --merge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
          BUILDER: ${{ github.actor }}@github-actions-release-job # Different builder ID for merge job
