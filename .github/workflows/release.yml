name: Release

on:
  push:
    branches:
      - "main"
      - "develop"
    tags:
      - 'v*'
    paths-ignore:
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/images/**'
      - 'config.toml'
      - 'docker-compose.yml'
      - 'Makefile'
      - '**.md'
  pull_request:
    paths-ignore:
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/images/**'
      - 'config.toml'
      - 'docker-compose.yml'
      - 'Makefile'
      - '**.md'

env:
  REGISTRY: ghcr.io
  REGISTRY_IMAGE: ghcr.io/${{ github.repository }}
  GO_VERSION: "1.24"

permissions:
  contents: write
  packages: write

jobs:
  test:
    strategy:
      fail-fast: true
      matrix:
        os: [ ubuntu-latest ]
    name: Test ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run Tests with Race Detection
        env:
          CGO_ENABLED: 1
        run: make test-race

  testother:
    strategy:
      fail-fast: true
      matrix:
        os: [ macos-latest, windows-latest ]
    name: Test ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    env:
      GOPATH: ${{ startsWith(matrix.os, 'windows') && 'D:\golang\go' || '' }}
      GOCACHE: ${{ startsWith(matrix.os, 'windows') && 'D:\golang\cache' || '' }}
      GOMODCACHE: ${{ startsWith(matrix.os, 'windows') && 'D:\golang\modcache' || '' }}
      USERPROFILE: ${{ startsWith(matrix.os, 'windows') && 'D:\homedir' || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run Tests (MacOS)
        if: matrix.os == 'macos-latest'
        env:
          CGO_ENABLED: 1
        run: go test ./...

      #- name: Run Tests (Windows)
      #  if: matrix.os == 'windows-latest'
      #  env:
      #    CGO_ENABLED: 1
      #  run: go test -short ./...

      - name: Generate Test Summary
        if: matrix.os != 'windows-latest'
        run: go run gotest.tools/gotestsum@latest --junitfile unit-tests.xml --format pkgname

      - name: Test Summary
        uses: test-summary/action@v2
        with:
          paths: "unit-tests.xml"
        if: always() && matrix.os != 'windows-latest'

  pgo:
    name: Generate PGO Profile
    runs-on: ubuntu-latest
    needs: [ test, testother ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Create test data for profiling
        shell: bash
        run: |
          mkdir -p test_data
          dd if=/dev/urandom of=test_data/test1.bin bs=1M count=100
          dd if=/dev/urandom of=test_data/test2.bin bs=1M count=100
          for i in {1..20000}; do dd if=/dev/urandom bs=1023 count=1 of=test_data/file$i.bin >/dev/null 2>&1; done

      - name: Generate Profile
        env:
          CGO_ENABLED: 0
        run: |
          # Build initial binary
          go build -o mkbrr ./cmd/mkbrr/

          # Run different workload scenarios
          ./mkbrr create test_data/test1.bin --cpuprofile=cpu1.pprof
          ./mkbrr create test_data/test2.bin --cpuprofile=cpu2.pprof
          ./mkbrr create test_data --cpuprofile=cpu3.pprof

          # Verify profiles exist
          if [ ! -f cpu1.pprof ] || [ ! -f cpu2.pprof ] || [ ! -f cpu3.pprof ]; then
            echo "Error: One or more profile files not generated"
            ls -la *.pprof
            exit 1
          fi

          # Merge profiles
          go tool pprof -proto cpu1.pprof cpu2.pprof cpu3.pprof > cpu.pprof

          # Verify final profile
          if [ ! -s cpu.pprof ]; then
            echo "Error: Final profile not generated or empty"
            exit 1
          fi

      - name: Upload pprof
        uses: actions/upload-artifact@v4
        with:
          name: pprof
          path: cpu.pprof

  # Build GUI for macOS has to happen on macos-latest runner (xcode)
  build-gui-darwin:
    name: Build GUI for Darwin
    runs-on: macos-latest
    needs: [ test, testother ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          
      - name: Install Fyne CLI
        run: go install fyne.io/tools/cmd/fyne@latest
        
      - name: Build macOS GUI executable
        run: make build-gui

      - name: Package macOS GUI app bundle
        run: |
          fyne package --executable build/mkbrr-gui --os darwin --name mkbrr-gui --id com.autobrr.mkbrr --icon .github/assets/logo.png
          ls -la

      - name: Create DMG for macOS app bundle
        run: |
          # Define variables
          APP_NAME="mkbrr-gui"
          APP_BUNDLE="$APP_NAME.app"
          VOL_NAME="$APP_NAME" # Volume name inside the DMG
          DMG_NAME="$APP_NAME-darwin-universal.DMG"
          TEMP_DMG="temp_$DMG_NAME"
          
          # Check if app bundle exists
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "Error: $APP_BUNDLE not found!"
            exit 1
          fi
          
          echo "Creating temporary DMG..."
          # Estimate size needed (add some buffer)
          APP_SIZE=$(du -sm "$APP_BUNDLE" | awk '{print $1}')
          DMG_SIZE=$((APP_SIZE + 50)) # Add 50MB buffer
          
          hdiutil create -srcfolder "$APP_BUNDLE" -volname "$VOL_NAME" -fs HFS+ -fsargs "-c c=64,a=16,e=16" -format UDRW -size ${DMG_SIZE}m "$TEMP_DMG"
          
          echo "Mounting temporary DMG..."
          MOUNT_DIR=$(hdiutil attach "$TEMP_DMG" -nobrowse -noverify -noautoopen | grep Volumes | sed 's/.*\/Volumes\///')
          if [ -z "$MOUNT_DIR" ]; then
            echo "Error: Failed to mount temporary DMG"
            exit 1
          fi
          VOLUME_PATH="/Volumes/$MOUNT_DIR"
          
          echo "Mounted at $VOLUME_PATH"
          # Add symlink to Applications folder
          ln -s /Applications "$VOLUME_PATH/Applications"
          
          echo "Unmounting DMG..."
          hdiutil detach "$VOLUME_PATH"
          
          echo "Converting to final compressed DMG..."
          hdiutil convert "$TEMP_DMG" -format UDZO -imagekey zlib-level=9 -o "$DMG_NAME"
          
          echo "Cleaning up temporary DMG..."
          rm "$TEMP_DMG"
          
          echo "DMG created: $DMG_NAME"
          ls -lh "$DMG_NAME"

      - name: Upload macOS DMG
        uses: actions/upload-artifact@v4
        with:
          name: darwin-gui-artifact-DMG # Use a distinct name for the DMG artifact
          path: mkbrr-gui-darwin-universal.DMG # Path to the DMG file

  goreleaserbuild:
    name: Build distribution binaries
    runs-on: ubuntu-latest
    needs: [ pgo, build-gui-darwin ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Create destination directories
        run: |
          mkdir -p dist/darwin
          mkdir -p dist/windows

      - name: Download pprof
        uses: actions/download-artifact@v4
        with:
          name: pprof
          path: .
          
      - name: Download macOS DMG
        uses: actions/download-artifact@v4
        with:
          name: darwin-gui-artifact-DMG # Match the uploaded artifact name
          path: dist/ # Download directly into the dist directory where GoReleaser looks
          
      # No extraction needed for DMG
          
      - name: Debug - List downloaded artifact
        run: |
          echo "Listing dist directory after DMG download:"
          ls -la dist/ || echo "Directory dist not found or empty"
          echo ""
          echo "Listing full dist directory recursively:"
          find dist -type f -ls 2>/dev/null || echo "No files found in dist/"

      - name: Install fyne-cross
        run: go install github.com/fyne-io/fyne-cross@latest
          
      - name: Build GUI for Windows and Linux
        run: |
          # Build Windows GUI binaries
          fyne-cross windows -arch=amd64,arm64 -app-id=com.autobrr.mkbrr --icon .github/assets/logo.png -output=mkbrr-gui ./cmd/mkbrr-gui/
          # Build Linux GUI binaries
          fyne-cross linux -arch=amd64,arm64 -app-id=com.autobrr.mkbrr --icon .github/assets/logo.png -output=mkbrr-gui ./cmd/mkbrr-gui/
          ls -la fyne-cross/bin/
          # Note: GoReleaser pulls directly from fyne-cross/bin/ directories
      
      - name: Run GoReleaser build
        if: github.event_name == 'pull_request'
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean --skip=validate,publish --parallelism 5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BUILDER: ${{ github.actor }}@github-actions

      - name: Run GoReleaser build and publish tags
        if: startsWith(github.ref, 'refs/tags/')
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BUILDER: ${{ github.actor }}@github-actions

      - name: Upload assets
        uses: actions/upload-artifact@v4
        with:
          name: mkbrr
          path: |
            dist/*.tar.gz
            dist/*.zip
            dist/*.deb
            dist/*.rpm

  docker:
    name: Build Docker images
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        platform:
          - linux/386
          - linux/amd64
          - linux/amd64/v2
          - linux/amd64/v3
          - linux/arm/v6
          - linux/arm/v7
          - linux/arm64
          # - linux/mips64le
          # - linux/mips64
          - linux/ppc64le
          # - linux/riscv64
          - linux/s390x
    needs: [ pgo, test ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download pprof profile
        uses: actions/download-artifact@v4
        with:
          name: pprof

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE }}
          tags: |
            type=semver,pattern={{version}},prefix=v
            type=semver,pattern={{major}}.{{minor}},prefix=v
            type=ref,event=branch
            type=ref,event=pr
          flavor: |
            latest=auto

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Supported Architectures
        run: docker buildx ls

      - name: Build and publish image
        id: docker_build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: './ci.Dockerfile'
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=${{ env.REGISTRY_IMAGE }},push-by-digest=true,name-canonical=true,push=${{ (github.event.pull_request.head.repo.full_name == github.repository || github.event_name != 'pull_request') && 'true' || 'false' }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

      - name: Export image digest
        id: digest-prep
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.docker_build.outputs.digest }}"
          echo "manifest-hash=${digest#sha256:}" >> "$GITHUB_OUTPUT"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload image digest
        uses: actions/upload-artifact@v4
        with:
          name: docker-digests-${{ steps.digest-prep.outputs.manifest-hash }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  docker-merge:
    name: Publish Docker multi-arch manifest
    if: ${{ github.event.pull_request.head.repo.full_name == github.repository || github.event_name != 'pull_request' }}
    runs-on: ubuntu-latest
    needs: [ docker ]
    steps:
      - name: Download image digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: docker-digests-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE }}
          tags: |
            type=semver,pattern={{version}},prefix=v
            type=semver,pattern={{major}}.{{minor}},prefix=v
            type=ref,event=branch
            type=ref,event=pr
          flavor: |
            latest=auto

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY_IMAGE }}@sha256:%s ' *)

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY_IMAGE }}:${{ steps.meta.outputs.version }}